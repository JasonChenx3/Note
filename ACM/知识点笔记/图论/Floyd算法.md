#### Floyd 算法

1. 时间复杂度：$O(n^3)$

2. 应用
   1. 最短路
   2. 传递闭包
   3. 找最小环
   4. 恰好经过 k 条边的最短路（倍增）

3. 正确性证明

   - 状态表示

   `f[k, i, j]`：所有从 i 出发，最终走到 j ，且中间只经过编号为 1 ~ k 的所有路径。

   属性：路径长度最小值。

   - 状态计算

   所有不含节点 k 的路径：`d[k - 1, i, j]`

   所有包含节点 k 的路径：`d[k - 1, i, k] + d[k - 1, k, j]`
   
   `d[k, i, j] = min(d[k - 1, i, j], d[k - 1, i, k] + d[k - 1, k, j]);`
   
   因此可以将第一维优化掉。

#### 传递闭包

**含义：**给所有能间接到达的点，连一条边。

**例如：**`d[i][k] = true, d[k][j] = true` ，那么 `d[i][j] = true` 。

**步骤：**

1. 初始化 `d[i][j] = g[i][j]` ，也可用 memcpy 。
2. `if(d[i][k] && d[k][j]) d[i][j] = 1;` 
